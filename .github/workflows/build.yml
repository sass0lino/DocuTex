name: Build LaTeX documents

permissions:
  contents: write

on:
  push:
    branches:
      - main
    paths:
      - 'src/**/*.tex'

jobs:
  build_latex:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Step 1 - State Reconciliation and Cleanup
        id: cleanup
        run: |
          # (Logica invariata)
          if [ -d "docs" ]; then
            find docs -type f -name "*.pdf" | while IFS= read -r pdf_file; do
              src_file=$(echo "$pdf_file" | sed 's|^docs/|src/|; s|\.pdf$|\.tex|')
              if [ ! -f "$src_file" ]; then rm "$pdf_file"; fi
            done
          fi
          touch compilation_failures.log
          find src -type f -name "*.tex" | grep -v '/contenuti/' > all_current_files.txt
          awk -F';' 'NR==FNR{a[$1]=1; next} a[$1]' all_current_files.txt compilation_failures.log > temp_log.log
          mv temp_log.log compilation_failures.log
          rm all_current_files.txt

      - name: Step 2 - Identify Files to Compile
        id: prepare
        run: |
          # (Logica invariata)
          BEFORE_SHA="${{ github.event.before }}"; AFTER_SHA="${{ github.event.after }}"
          if [[ "$BEFORE_SHA" == "0000000000000000000000000000000000000000" ]]; then
            changed_files=$(git ls-tree --name-only -r "$AFTER_SHA" | grep '\.tex$' || true)
          else
            changed_files=$(git diff --name-only --diff-filter=AMR "$BEFORE_SHA" "$AFTER_SHA" | grep '\.tex$' || true)
          fi
          files_from_log=$(awk -F';' '{print $1}' compilation_failures.log)
          compile_list_from_changes=""
          if [ -n "$changed_files" ]; then
            while IFS= read -r file; do
              if [[ "$file" == *"/contenuti/"* ]]; then
                parent_dir=$(echo "$file" | sed 's|/contenuti/.*||'); target_files=$(find "$parent_dir" -maxdepth 1 -type f -name "*.tex")
                if [ -n "$target_files" ]; then compile_list_from_changes="$compile_list_from_changes\n$target_files"; fi
              else
                compile_list_from_changes="$compile_list_from_changes\n$file"
              fi
            done < <(echo "$changed_files")
          fi
          master_compile_list=$(echo -e "$compile_list_from_changes\n$files_from_log" | sed '/^$/d' | sort -u)
          if [ -z "$master_compile_list" ]; then
            echo "No .tex files to compile."; echo "compile_needed=false" >> $GITHUB_OUTPUT
          else
            echo "$master_compile_list" > compile_list.txt; echo "compile_needed=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Step 3 - Preemptive Deletion & Compilation
        if: steps.prepare.outputs.compile_needed == 'true'
        run: |
          # (Logica invariata)
          cat compile_list.txt | while IFS= read -r file_to_compile; do
            filepath=$(dirname "$file_to_compile"); filename=$(basename "$file_to_compile" .tex)
            output_subpath=$(echo "$filepath" | sed 's|^src/||; s|^src$||')
            pdf_to_delete="docs/$output_subpath/$filename.pdf"
            if [ -f "$pdf_to_delete" ]; then rm "$pdf_to_delete"; fi
          done
          touch successes.log failures.log
          docker run --rm --volume "$(pwd)":"$(pwd)" --workdir "$(pwd)" -e GITHUB_SHA ghcr.io/xu-cheng/texlive-full:latest /bin/bash -c "
            cat compile_list.txt | while IFS= read -r final_file; do
              if latexmk -pdf -cd -interaction=nonstopmode -file-line-error -output-directory=\"\$(pwd)/tmp_build\" \"\$(pwd)/\$final_file\"; then
                filepath=\$(dirname \"\$final_file\"); filename=\$(basename \"\$final_file\" .tex); output_subpath=\$(echo \"\$filepath\" | sed 's|^src/||; s|^src\$||')
                output_dir=\"\$(pwd)/docs/\$output_subpath\"; mkdir -p \"\$output_dir\"
                mv \"\$(pwd)/tmp_build/\$filename.pdf\" \"\$output_dir/\"
                echo \"\$final_file\" >> successes.log
              else
                echo \"::error file=\$final_file::LaTeX compilation failed.\"
                echo \"\$final_file;\$GITHUB_SHA\" >> failures.log
              fi; rm -rf \"\$(pwd)/tmp_build\"
            done
          "

      - name: Step 4 - Update Failure Log and Commit
        if: steps.prepare.outputs.compile_needed == 'true'
        run: |
          # --- NUOVA LOGICA DI AGGIORNAMENTO DEL LOG, SEMPLICE E ROBUSTA ---
          echo "--- Updating failure log with a single, robust command ---"
          touch compilation_failures.log successes.log failures.log
          
          # 1. Combina i fallimenti vecchi e nuovi
          cat compilation_failures.log failures.log > temp_combined_failures.log

          # 2. Usa un singolo comando awk per filtrare i successi.
          # Carica i successi in memoria, poi scorre i fallimenti e stampa solo
          # quelli il cui percorso non Ã¨ nella lista dei successi.
          awk -F';' 'NR==FNR{successes[$0]=1; next} !(successes[$1])' successes.log temp_combined_failures.log > compilation_failures.log

          echo "Current failed files (file;commit_hash):"
          cat compilation_failures.log
          rm -f successes.log failures.log temp_combined_failures.log

          # Logica di commit
          git add docs compilation_failures.log
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git commit -m "Automated LaTeX compilation and state reconciliation"
            git push
          fi
