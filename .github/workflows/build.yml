name: Build LaTeX documents

permissions:
  contents: write

on:
  push:
    branches:
      - main
    paths:
      - 'src/**/*.tex'

jobs:
  build_latex:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Process LaTeX Files
        id: process_files
        run: |
          # --- PASSI 1, 2, 3 E 4 (invariati) ---
          # La logica per pulire, identificare, cancellare preventivamente e compilare
          # rimane esattamente la stessa.
          echo "--- Cleaning up old PDFs for deleted or renamed files ---"
          deleted_files=$(git diff --name-only --diff-filter=D HEAD~1 HEAD | grep '\.tex$' || true)
          renamed_from_files=$(git diff --name-only --diff-filter=R HEAD~1 HEAD | awk '{print $1}' | grep '\.tex$' || true)
          cleanup_list="$deleted_files\n$renamed_from_files"
          unique_cleanup_list=$(echo -e "$cleanup_list" | sed '/^$/d' | sort -u)
          if [ -n "$unique_cleanup_list" ]; then
            echo "$unique_cleanup_list" | while IFS= read -r file_to_clean; do
              filepath=$(dirname "$file_to_clean"); filename=$(basename "$file_to_clean" .tex)
              output_subpath=$(echo "$filepath" | sed 's|^src/||; s|^src$||')
              pdf_to_delete="docs/$output_subpath/$filename.pdf"
              if [ -f "$pdf_to_delete" ]; then echo "Deleting old PDF: $pdf_to_delete"; rm "$pdf_to_delete"; fi
            done
          fi
          echo -e "\n--- Identifying files to compile ---"
          changed_files=$(git diff --name-only --diff-filter=AMR HEAD~1 HEAD | grep '\.tex$' || true)
          if [ -z "$changed_files" ]; then echo "No .tex files to compile. Skipping."; exit 0; fi
          compile_list=""
          while IFS= read -r file; do
            if [[ "$file" == *"/contenuti/"* ]]; then
              parent_dir=$(echo "$file" | sed 's|/contenuti/.*||'); target_files=$(find "$parent_dir" -maxdepth 1 -type f -name "*.tex")
              if [ -n "$target_files" ]; then compile_list="$compile_list\n$target_files"; fi
            else
              compile_list="$compile_list\n$file"
            fi
          done < <(echo "$changed_files")
          unique_compile_list=$(echo -e "$compile_list" | sed '/^$/d' | sort -u)
          if [ -z "$unique_compile_list" ]; then echo "Could not determine any main .tex files to compile."; exit 0; fi
          echo -e "\nFinal list of files to compile:\n$unique_compile_list\n"
          echo "--- Preemptively deleting PDFs before recompilation ---"
          echo "$unique_compile_list" | while IFS= read -r file_to_compile; do
            filepath=$(dirname "$file_to_compile"); filename=$(basename "$file_to_compile" .tex)
            output_subpath=$(echo "$filepath" | sed 's|^src/||; s|^src$||')
            pdf_to_delete="docs/$output_subpath/$filename.pdf"
            if [ -f "$pdf_to_delete" ]; then echo "Deleting existing PDF: $pdf_to_delete"; rm "$pdf_to_delete"; fi
          done
          touch successes.log failures.log
          docker run --rm --volume "$(pwd)":"$(pwd)" --workdir "$(pwd)" -e GITHUB_SHA ghcr.io/xu-cheng/texlive-full:latest /bin/bash -c "
            echo 'Starting compilation loop...'
            echo \"$unique_compile_list\" | while IFS= read -r final_file; do
              echo \"--- Compiling: '\$final_file' ---\"
              if latexmk -pdf -cd -interaction=nonstopmode -file-line-error -output-directory=\"\$(pwd)/tmp_build\" \"\$(pwd)/\$final_file\"; then
                filepath=\$(dirname \"\$final_file\"); filename=\$(basename \"\$final_file\" .tex)
                output_subpath=\$(echo \"\$filepath\" | sed 's|^src/||; s|^src\$||')
                output_dir=\"\$(pwd)/docs/\$output_subpath\"; mkdir -p \"\$output_dir\"
                mv \"\$(pwd)/tmp_build/\$filename.pdf\" \"\$output_dir/\"
                echo \"\$final_file\" >> successes.log
              else
                echo \"::error file=\$final_file::LaTeX compilation failed.\"
                echo \"\$final_file;\$GITHUB_SHA\" >> failures.log
              fi
              rm -rf \"\$(pwd)/tmp_build\"
            done
          "

      - name: Update Failure Log
        run: |
          # --- LOGICA CORRETTA E ROBUSTA PER AGGIORNARE IL LOG ---
          echo "--- Updating compilation_failures.log ---"
          touch compilation_failures.log

          # 1. Combina i vecchi e i nuovi fallimenti in un file temporaneo
          cat compilation_failures.log failures.log | sort -u > temp_failures.log
          
          # 2. Se ci sono stati dei successi, li rimuove dalla lista
          if [ -s successes.log ]; then
            # Scorre ogni file che ha avuto successo
            while IFS= read -r successful_file; do
                # Scappa eventuali caratteri speciali nel nome del file per sicurezza
                escaped_file=$(printf '%s\n' "$successful_file" | sed 's/[.[\*^$]/\\&/g')
                # Usa il pattern corretto (^PERCORSO;) per rimuovere la riga corrispondente
                grep -v "^${escaped_file};" temp_failures.log > new_temp_failures.log
                mv new_temp_failures.log temp_failures.log
            done < successes.log
          fi

          # 3. Sovrascrive il vecchio log con quello aggiornato
          mv temp_failures.log compilation_failures.log

          echo "Current failed files (file;commit_hash):"
          cat compilation_failures.log
          rm -f successes.log failures.log

      - name: Commit & Push PDF and Failure Log
        run: |
          # (Logica di commit invariata)
          git add docs compilation_failures.log
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"
            git commit -m "Automated LaTeX compilation and updated failure log"
            git push
          fi
